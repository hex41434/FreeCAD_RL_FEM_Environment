{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RLFEM # Reinforcement Learning Environment for FEM Simulations based on FreeCAD. Installation # Dependencies: gym freecad As freecad is only available as a conda package, you should install RLFEM as: conda create --name my_env freecad -c conda-forge conda activate my_env pip install gym pip install git+https://github.com/hex41434/FreeCAD_RL_FEM_Simulator.git@master","title":"Home"},{"location":"#rlfem","text":"Reinforcement Learning Environment for FEM Simulations based on FreeCAD.","title":"RLFEM"},{"location":"#installation","text":"Dependencies: gym freecad As freecad is only available as a conda package, you should install RLFEM as: conda create --name my_env freecad -c conda-forge conda activate my_env pip install gym pip install git+https://github.com/hex41434/FreeCAD_RL_FEM_Simulator.git@master","title":"Installation"},{"location":"FreeCADWrapper/","text":"FreeCADWrapper # RLFEM.FreeCADWrapper # FreeCADWrapper # Class allowing to interact with the FreeCad simulation. TODO: more description __init__ ( self , path = '' ) special # Args: path: path to the .ply file. Source code in RLFEM/FreeCADWrapper.py def __init__ ( self , path = '' ): \"\"\" Args: path: path to the .ply file. \"\"\" self . path = path # TODO: add the number of actions (sequence) and repeat until it's satisfied # doc = FreeCAD.getDocument(\"Unnamed\") # CHANGE LATER! self . doc = App . newDocument ( \"doc\" ) if not ( self . path == '' ): self . insert_mesh () else : # TODO: correct the dimensions obj = self . doc . addObject ( 'Part::Box' , 'Box' ) obj . Height = 2 obj . Width = 5 obj . Length = 50 self . obj = self . doc . Objects [ - 1 ] if ( self . obj . Module == 'Mesh' ): self . convert2solidmesh () self . obj = self . doc . Objects [ - 1 ] self . box_obj = self . doc . addObject ( 'Part::Box' , 'Box' ) # box_obj.ViewObject.Visibility = False self . v_CoM , self . v_NoF = self . extract_info_mesh ( self . obj ) self . min_vals = self . v_CoM . min ( axis = 0 ) self . max_vals = self . v_CoM . max ( axis = 0 ) self . obj_dims = abs ( self . max_vals - self . min_vals ) self . LENGTH = self . obj_dims [ 0 ] # x direction self . WIDTH = self . obj_dims [ 1 ] # y direction self . HEIGHT = self . obj_dims [ 2 ] # z direction self . NUM_BIN = 1000 self . flag_elong = 'length' self . calc_epsilon () self . v_CoM_sorted = self . get_sorted_CoM ( self . v_CoM , self . column_index )","title":"FreeCADWrapper"},{"location":"FreeCADWrapper/#freecadwrapper","text":"","title":"FreeCADWrapper"},{"location":"FreeCADWrapper/#RLFEM.FreeCADWrapper","text":"","title":"FreeCADWrapper"},{"location":"FreeCADWrapper/#RLFEM.FreeCADWrapper.FreeCADWrapper","text":"Class allowing to interact with the FreeCad simulation. TODO: more description","title":"FreeCADWrapper"},{"location":"FreeCADWrapper/#RLFEM.FreeCADWrapper.FreeCADWrapper.__init__","text":"Args: path: path to the .ply file. Source code in RLFEM/FreeCADWrapper.py def __init__ ( self , path = '' ): \"\"\" Args: path: path to the .ply file. \"\"\" self . path = path # TODO: add the number of actions (sequence) and repeat until it's satisfied # doc = FreeCAD.getDocument(\"Unnamed\") # CHANGE LATER! self . doc = App . newDocument ( \"doc\" ) if not ( self . path == '' ): self . insert_mesh () else : # TODO: correct the dimensions obj = self . doc . addObject ( 'Part::Box' , 'Box' ) obj . Height = 2 obj . Width = 5 obj . Length = 50 self . obj = self . doc . Objects [ - 1 ] if ( self . obj . Module == 'Mesh' ): self . convert2solidmesh () self . obj = self . doc . Objects [ - 1 ] self . box_obj = self . doc . addObject ( 'Part::Box' , 'Box' ) # box_obj.ViewObject.Visibility = False self . v_CoM , self . v_NoF = self . extract_info_mesh ( self . obj ) self . min_vals = self . v_CoM . min ( axis = 0 ) self . max_vals = self . v_CoM . max ( axis = 0 ) self . obj_dims = abs ( self . max_vals - self . min_vals ) self . LENGTH = self . obj_dims [ 0 ] # x direction self . WIDTH = self . obj_dims [ 1 ] # y direction self . HEIGHT = self . obj_dims [ 2 ] # z direction self . NUM_BIN = 1000 self . flag_elong = 'length' self . calc_epsilon () self . v_CoM_sorted = self . get_sorted_CoM ( self . v_CoM , self . column_index )","title":"__init__()"},{"location":"RLFEM/","text":"RLFEM # RLFEM.RLFEM # RLFEM # Environment allowing to interact with the FreeCad simulation. TODO: more description __init__ ( self , path = '' ) special # Parameters: Name Type Description Default path path to the .ply file. '' Source code in RLFEM/RLFEM.py def __init__ ( self , path = '' ): \"\"\" :param path: path to the .ply file. \"\"\" self . path = path self . interface = FreeCADWrapper ( self . path ) self . state = self . reset () super () . __init__ () close ( self ) # To be called before exiting, to free resources. Source code in RLFEM/RLFEM.py def close ( self ): \"To be called before exiting, to free resources.\" pass render ( self , mode = 'human' ) # Displays the current state of the environment. Can be text or video frames. Source code in RLFEM/RLFEM.py def render ( self , mode = 'human' ): \"\"\"Displays the current state of the environment. Can be text or video frames. \"\"\" print ( self . state ) reset ( self ) # Resets the environment and starts from an initial state. Returns: Type Description the initial state. Source code in RLFEM/RLFEM.py def reset ( self ): \"\"\"Resets the environment and starts from an initial state. :returns: the initial state. \"\"\" # Initial state # self.state = self.interface.reset() return self . state step ( self , action ) # Takes an action in the environment and returns a new state, a reward, a boolean (True for terminal states) and a dictionary with additional info (optional). Parameters: Name Type Description Default action the action to be taken. required Returns: Type Description (next_state, reward, done, info) Source code in RLFEM/RLFEM.py def step ( self , action ): \"\"\"Takes an action in the environment and returns a new state, a reward, a boolean (True for terminal states) and a dictionary with additional info (optional). :param action: the action to be taken. :returns: (next_state, reward, done, info) \"\"\" self . state = self . interface . apply ( action ) # Random transition to another state self . reward = np . random . uniform ( 0 , 1 , 1 )[ 0 ] # Random reward self . done = False # Continuing task self . info = {} # No info return self . state , self . reward , self . done , self . info","title":"RLFEM"},{"location":"RLFEM/#rlfem","text":"","title":"RLFEM"},{"location":"RLFEM/#RLFEM.RLFEM","text":"","title":"RLFEM"},{"location":"RLFEM/#RLFEM.RLFEM.RLFEM","text":"Environment allowing to interact with the FreeCad simulation. TODO: more description","title":"RLFEM"},{"location":"RLFEM/#RLFEM.RLFEM.RLFEM.__init__","text":"Parameters: Name Type Description Default path path to the .ply file. '' Source code in RLFEM/RLFEM.py def __init__ ( self , path = '' ): \"\"\" :param path: path to the .ply file. \"\"\" self . path = path self . interface = FreeCADWrapper ( self . path ) self . state = self . reset () super () . __init__ ()","title":"__init__()"},{"location":"RLFEM/#RLFEM.RLFEM.RLFEM.close","text":"To be called before exiting, to free resources. Source code in RLFEM/RLFEM.py def close ( self ): \"To be called before exiting, to free resources.\" pass","title":"close()"},{"location":"RLFEM/#RLFEM.RLFEM.RLFEM.render","text":"Displays the current state of the environment. Can be text or video frames. Source code in RLFEM/RLFEM.py def render ( self , mode = 'human' ): \"\"\"Displays the current state of the environment. Can be text or video frames. \"\"\" print ( self . state )","title":"render()"},{"location":"RLFEM/#RLFEM.RLFEM.RLFEM.reset","text":"Resets the environment and starts from an initial state. Returns: Type Description the initial state. Source code in RLFEM/RLFEM.py def reset ( self ): \"\"\"Resets the environment and starts from an initial state. :returns: the initial state. \"\"\" # Initial state # self.state = self.interface.reset() return self . state","title":"reset()"},{"location":"RLFEM/#RLFEM.RLFEM.RLFEM.step","text":"Takes an action in the environment and returns a new state, a reward, a boolean (True for terminal states) and a dictionary with additional info (optional). Parameters: Name Type Description Default action the action to be taken. required Returns: Type Description (next_state, reward, done, info) Source code in RLFEM/RLFEM.py def step ( self , action ): \"\"\"Takes an action in the environment and returns a new state, a reward, a boolean (True for terminal states) and a dictionary with additional info (optional). :param action: the action to be taken. :returns: (next_state, reward, done, info) \"\"\" self . state = self . interface . apply ( action ) # Random transition to another state self . reward = np . random . uniform ( 0 , 1 , 1 )[ 0 ] # Random reward self . done = False # Continuing task self . info = {} # No info return self . state , self . reward , self . done , self . info","title":"step()"}]}